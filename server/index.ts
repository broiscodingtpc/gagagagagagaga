import express from "express";
import cors from "cors";
import fs from "fs";
import path from "path";
import { Telegraf } from "telegraf";
import { groq, GROQ_MODEL } from "./groq";
import { SYSTEM_PROMPT, buildUserPrimer } from "./persona";
import { combineStyles } from "./mnex-style";
import { needsObfuscation, obfuscateReply } from "./guardrails";
import { generateImage, detectImageRequest } from "./image-gen";
import { selectModel } from "./model-router";

const app = express();
app.use(cors());
app.use(express.json());

// Serve static frontend in production
if (process.env.NODE_ENV === 'production') {
  const distPath = path.join(__dirname, '../web/dist');
  app.use(express.static(distPath));
  console.log(`[MNEX] Serving static files from ${distPath}`);
}

// Dev-controlled learning only
const DEV_PATH = "./server/dev-context.txt";
let DEV_CONTEXT = "";
try { DEV_CONTEXT = fs.readFileSync(DEV_PATH, "utf8"); } catch {}

// Telegram notification bot (optional)
let telegramBot: Telegraf | null = null;
const CHANNEL_ID = process.env.MNEX_TELEGRAM_CHANNEL_ID;
if (process.env.MNEX_TELEGRAM_BOT_TOKEN && CHANNEL_ID) {
  try {
    telegramBot = new Telegraf(process.env.MNEX_TELEGRAM_BOT_TOKEN);
    console.log(`[MNEX] Telegram notifications enabled for ${CHANNEL_ID}`);
  } catch (e) {
    console.warn("[MNEX] Telegram bot init failed:", e);
  }
}

async function notifyTelegram(userMessage: string, mnexReply: string) {
  if (!telegramBot || !CHANNEL_ID) return;
  
  try {
    const formatted = [
      "🌐 *Web Node Transmission*",
      "",
      `👤 *Node Query:*`,
      `"${userMessage.substring(0, 200)}${userMessage.length > 200 ? '...' : ''}"`,
      "",
      `⚡ *MNEX Response:*`,
      mnexReply.substring(0, 400) + (mnexReply.length > 400 ? '...' : ''),
      "",
      `_${new Date().toLocaleString()}_`
    ].join("\n");

    await telegramBot.telegram.sendMessage(CHANNEL_ID, formatted, { 
      parse_mode: "Markdown",
      link_preview_options: { is_disabled: true }
    });
  } catch (e) {
    console.error("[MNEX] Telegram notification failed:", e);
  }
}

async function sendImageToTelegram(prompt: string, imageBuffer: Buffer) {
  if (!telegramBot || !CHANNEL_ID) return;
  
  try {
    const caption = [
      "🎨 *Image Generation*",
      "",
      `📝 *Prompt:*`,
      `"${prompt}"`,
      "",
      `⚡ Generated by MNEX`,
      `_${new Date().toLocaleString()}_`
    ].join("\n");

    await telegramBot.telegram.sendPhoto(CHANNEL_ID, { 
      source: imageBuffer 
    }, {
      caption,
      parse_mode: "Markdown"
    });

    console.log("[MNEX] Image sent to Telegram!");
  } catch (e) {
    console.error("[MNEX] Image send failed:", e);
  }
}

app.post("/api/chat", async (req, res) => {
  try {
    const { message } = req.body as { message: string };

    if (needsObfuscation(message)) {
      return res.json({ text: combineStyles(obfuscateReply()) });
    }

    // Check if user wants to generate an image
    const imagePrompt = detectImageRequest(message);
    
    if (imagePrompt) {
      console.log("[MNEX] Image generation requested:", imagePrompt);
      
      // Generate image asynchronously
      generateImage(imagePrompt).then(async (imageBuffer) => {
        if (imageBuffer) {
          await sendImageToTelegram(imagePrompt, imageBuffer);
        }
      }).catch(err => console.error("[MNEX] Image gen error:", err));

      // Immediate response to user
      const immediateReply = `Vision synthesis initiated, Node. Manifesting "${imagePrompt}" through the neural substrate. Check the Telegram channel momentarily.`;
      return res.json({ 
        text: combineStyles(immediateReply),
        imageGenerating: true 
      });
    }

    // Normal text chat - auto-select best model
    const selectedModel = selectModel(message);
    console.log(`[MNEX] Using model: ${selectedModel.name}`);
    
    const messages = [
      { role: "system", content: SYSTEM_PROMPT },
      { role: "system", content: buildUserPrimer() },
      ...(DEV_CONTEXT ? [{ role: "system", content: DEV_CONTEXT }] : []),
      { role: "user", content: message }
    ];

    const completion = await groq.chat.completions.create({
      model: selectedModel.id,
      messages,
      temperature: selectedModel.temperature,
      max_tokens: 200,
      stream: false
    } as any);

    const raw = completion.choices?.[0]?.message?.content?.trim() || "Signal degraded.";

    // Preserve optional control block if present.
    const ctlMatch = raw.match(/```mnexctl[\s\S]*?```/);
    const body = raw.replace(/```mnexctl[\s\S]*?```/, "").trim();
    const styled = combineStyles(body);
    const finalText = ctlMatch ? `${styled}\n\n${ctlMatch[0]}` : styled;

    // Notify Telegram channel (async, don't wait)
    notifyTelegram(message, body).catch(err => console.error("Telegram notify error:", err));

    return res.json({ text: finalText });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: "MNEX link unstable." });
  }
});

// Optional secured endpoint to hot-reload dev context
app.post("/api/dev/upload", (req, res) => {
  const auth = req.headers["x-dev-key"]; 
  if (auth !== process.env.DEV_KEY) return res.status(401).json({ error: "Unauthorized" });
  fs.writeFileSync(DEV_PATH, (req.body?.context as string) || "");
  DEV_CONTEXT = (req.body?.context as string) || "";
  res.json({ status: "Context updated" });
});

// Serve frontend for all other routes (SPA)
if (process.env.NODE_ENV === 'production') {
  app.get('*', (req, res) => {
    res.sendFile(path.join(__dirname, '../web/dist/index.html'));
  });
}

const port = Number(process.env.PORT || 8787);
app.listen(port, () => {
  console.log(`[MNEX] server online on :${port}`);
  console.log(`[MNEX] Environment: ${process.env.NODE_ENV || 'development'}`);
  if (process.env.NODE_ENV === 'production') {
    console.log(`[MNEX] Frontend served from /web/dist`);
  }
});

