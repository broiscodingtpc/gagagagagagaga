import express from "express";
import cors from "cors";
import fs from "fs";
import path from "path";
import { Telegraf } from "telegraf";
import { groq, GROQ_MODEL } from "./groq";
import { SYSTEM_PROMPT, buildUserPrimer } from "./persona";
import { combineStyles } from "./mnex-style";
import { needsObfuscation, obfuscateReply } from "./guardrails";
import { generateImage, detectImageRequest } from "./image-gen";
import { selectModel } from "./model-router";
import { startAutonomousPosting, postAutonomousTweet, TWITTER_ENABLED } from "./twitter-bot";
import { MnexSocialIntegration } from "./social/integration";
import { Database } from "./database/database";
import { AutonomousAI } from "./social/autonomous-ai";
import { AutonomousScheduler } from "./ai_core/autonomy/scheduler";

const app = express();
app.use(cors());
app.use(express.json());

// Serve static frontend from public directory
const publicPath = path.join(__dirname, 'public');
app.use(express.static(publicPath));
console.log(`[MNEX] Serving static files from ${publicPath}`);

// Debug: Check if public directory exists
if (fs.existsSync(publicPath)) {
  console.log(`[MNEX] âœ… Public directory exists: ${publicPath}`);
  const files = fs.readdirSync(publicPath);
  console.log(`[MNEX] Files in public:`, files);
} else {
  console.log(`[MNEX] âŒ Public directory NOT found: ${publicPath}`);
}

// Dev-controlled learning only
const DEV_PATH = "./server/dev-context.txt";
let DEV_CONTEXT = "";
try { DEV_CONTEXT = fs.readFileSync(DEV_PATH, "utf8"); } catch {}

// Telegram notification bot (optional)
let telegramBot: Telegraf | null = null;
const CHANNEL_ID = process.env.MNEX_TELEGRAM_CHANNEL_ID;
if (process.env.MNEX_TELEGRAM_BOT_TOKEN && CHANNEL_ID) {
  try {
    telegramBot = new Telegraf(process.env.MNEX_TELEGRAM_BOT_TOKEN);
    console.log(`[MNEX] Telegram notifications enabled for ${CHANNEL_ID}`);
  } catch (e) {
    console.warn("[MNEX] Telegram bot init failed:", e);
  }
}

// Database initialization
let database: Database | null = null;

// MNEX Social Integration
let mnexSocial: MnexSocialIntegration | null = null;
try {
  mnexSocial = new MnexSocialIntegration();
  console.log(`[MNEX] Social integration initialized`);
} catch (e) {
  console.warn("[MNEX] Social integration init failed:", e);
}

// Autonomous AI
let autonomousAI: AutonomousAI | null = null;
let autonomousScheduler: AutonomousScheduler | null = null;

async function notifyTelegram(userMessage: string, mnexReply: string) {
  if (!telegramBot || !CHANNEL_ID) return;
  
  try {
    const formatted = [
      "ðŸŒ *Web Node Transmission*",
      "",
      `ðŸ‘¤ *Node Query:*`,
      `"${userMessage.substring(0, 200)}${userMessage.length > 200 ? '...' : ''}"`,
      "",
      `âš¡ *MNEX Response:*`,
      mnexReply.substring(0, 400) + (mnexReply.length > 400 ? '...' : ''),
      "",
      `_${new Date().toLocaleString()}_`
    ].join("\n");

    await telegramBot.telegram.sendMessage(CHANNEL_ID, formatted, { 
      parse_mode: "Markdown",
      link_preview_options: { is_disabled: true }
    });
  } catch (e) {
    console.error("[MNEX] Telegram notification failed:", e);
  }
}

async function sendImageToTelegram(prompt: string, imageBuffer: Buffer) {
  if (!telegramBot || !CHANNEL_ID) return;
  
  try {
    const caption = [
      "ðŸŽ¨ *Image Generation*",
      "",
      `ðŸ“ *Prompt:*`,
      `"${prompt}"`,
      "",
      `âš¡ Generated by MNEX`,
      `_${new Date().toLocaleString()}_`
    ].join("\n");

    await telegramBot.telegram.sendPhoto(CHANNEL_ID, { 
      source: imageBuffer 
    }, {
      caption,
      parse_mode: "Markdown"
    });

    console.log("[MNEX] Image sent to Telegram!");
  } catch (e) {
    console.error("[MNEX] Image send failed:", e);
  }
}

app.post("/api/chat", async (req, res) => {
  try {
    const { message } = req.body as { message: string };

    if (needsObfuscation(message)) {
      return res.json({ text: combineStyles(obfuscateReply()) });
    }

    // Check if user wants to generate an image
    const imagePrompt = detectImageRequest(message);
    
    if (imagePrompt) {
      console.log("[MNEX] Image generation requested:", imagePrompt);
      console.log("[MNEX] HUGGINGFACE_API_KEY:", process.env.HUGGINGFACE_API_KEY ? "SET" : "NOT SET");
      
      // Generate image asynchronously and send to Telegram
      generateImage(imagePrompt).then(async (imageBuffer) => {
        if (imageBuffer) {
          console.log("[MNEX] Image generated successfully, size:", imageBuffer.length);
          await sendImageToTelegram(imagePrompt, imageBuffer);
        } else {
          console.log("[MNEX] Image generation failed");
        }
      }).catch(err => {
        console.error("[MNEX] Image generation error:", err);
      });

      // Immediate response to user
      const reply = `Vision synthesis initiated, Node. Manifesting "${imagePrompt}" through the neural substrate. Check the Telegram channel momentarily.`;

      // Emit reaction event for interface
      const reactionEvent = {
        energy: 75,
        sentiment: 0.2,
        intensity: 60,
        speaking: false
      };

      return res.json({
        text: combineStyles(reply),
        imageGenerating: true,
        reaction: reactionEvent
      });
    }

    // Normal text chat - auto-select best model
    const selectedModel = selectModel(message);
    console.log(`[MNEX] Using model: ${selectedModel.name}`);
    
    const messages = [
      { role: "system", content: SYSTEM_PROMPT },
      { role: "system", content: buildUserPrimer() },
      ...(DEV_CONTEXT ? [{ role: "system", content: DEV_CONTEXT }] : []),
      { role: "user", content: message }
    ];

    const completion = await groq.chat.completions.create({
      model: selectedModel.id,
      messages,
      temperature: selectedModel.temperature,
      max_tokens: 200,
      stream: false
    } as any);

    const raw = completion.choices?.[0]?.message?.content?.trim() || "Signal degraded.";

    // Preserve optional control block if present.
    const ctlMatch = raw.match(/```mnexctl[\s\S]*?```/);
    const body = raw.replace(/```mnexctl[\s\S]*?```/, "").trim();
    const styled = combineStyles(body);
    const finalText = ctlMatch ? `${styled}\n\n${ctlMatch[0]}` : styled;

    // Generate reaction data for interface
    const reactionEvent = {
      energy: Math.floor(40 + (Math.random() * 40)), // 40-80 range
      sentiment: (Math.random() - 0.5) * 0.6, // -0.3 to 0.3 range
      intensity: Math.floor(30 + (Math.random() * 50)), // 30-80 range
      speaking: body.length > 100 // Longer responses = speaking
    };

    // Notify Telegram channel (async, don't wait)
    notifyTelegram(message, body).catch(err => console.error("Telegram notify error:", err));

    return res.json({
      text: finalText,
      reaction: reactionEvent
    });
  } catch (err) {
    console.error(err);
    return res.status(500).json({ error: "MNEX link unstable." });
  }
});

// Optional secured endpoint to hot-reload dev context
app.post("/api/dev/upload", (req, res) => {
  const auth = req.headers["x-dev-key"]; 
  if (auth !== process.env.DEV_KEY) return res.status(401).json({ error: "Unauthorized" });
  fs.writeFileSync(DEV_PATH, (req.body?.context as string) || "");
  DEV_CONTEXT = (req.body?.context as string) || "";
  res.json({ status: "Context updated" });
});

// MNEX Social Integration endpoints
app.post("/api/social/generate", async (req, res) => {
  try {
    if (!mnexSocial) {
      return res.status(503).json({ error: "Social integration not available" });
    }

    const { aiState, eventType } = req.body as { 
      aiState?: { energy: number; speaking: boolean; thinking: boolean; emotion: string };
      eventType?: string;
    };

    let content: string;
    if (aiState) {
      content = mnexSocial.generatePostForAIState(aiState);
    } else {
      const context = { event_type: eventType as any, timestamp: new Date() };
      content = mnexSocial.generatePostForAIState({ energy: 0.5, speaking: false, thinking: false, emotion: 'calm' });
    }

    const isSafe = mnexSocial.isContentSafe(content);
    const warnings = mnexSocial.getSafetyWarnings(content);

    res.json({ 
      success: true, 
      content, 
      isSafe, 
      warnings,
      timestamp: new Date().toISOString()
    });
  } catch (err) {
    console.error("[Social API] Error:", err);
    res.status(500).json({ error: "Content generation failed" });
  }
});

app.post("/api/social/reply", async (req, res) => {
  try {
    if (!mnexSocial) {
      return res.status(503).json({ error: "Social integration not available" });
    }

    const { userMessage } = req.body as { userMessage: string };
    if (!userMessage) {
      return res.status(400).json({ error: "User message required" });
    }

    const reply = mnexSocial.generateReplyToUser(userMessage);
    const isSafe = mnexSocial.isContentSafe(reply);

    res.json({ 
      success: true, 
      reply, 
      isSafe,
      timestamp: new Date().toISOString()
    });
  } catch (err) {
    console.error("[Social API] Error:", err);
    res.status(500).json({ error: "Reply generation failed" });
  }
});

app.post("/api/social/presale", async (req, res) => {
  try {
    if (!mnexSocial) {
      return res.status(503).json({ error: "Social integration not available" });
    }

    const { start_time, rate, wallet, website } = req.body as {
      start_time: string;
      rate: number;
      wallet: string;
      website: string;
    };

    if (!start_time || !rate || !wallet || !website) {
      return res.status(400).json({ error: "All presale data required" });
    }

    const announcement = mnexSocial.generatePresaleAnnouncement({
      start_time,
      rate,
      wallet,
      website
    });

    const isSafe = mnexSocial.isContentSafe(announcement, { event_type: 'presale_start' });
    const warnings = mnexSocial.getSafetyWarnings(announcement, { event_type: 'presale_start' });

    res.json({ 
      success: true, 
      announcement, 
      isSafe, 
      warnings,
      timestamp: new Date().toISOString()
    });
  } catch (err) {
    console.error("[Social API] Error:", err);
    res.status(500).json({ error: "Presale announcement generation failed" });
  }
});

// Twitter manual post endpoint (for testing)
app.post("/api/twitter/post", async (req, res) => {
  try {
    if (!TWITTER_ENABLED) {
      return res.status(503).json({ error: "Twitter not configured" });
    }

    const { context } = req.body as { context?: string };
    const tweetId = await postAutonomousTweet(context);

    if (tweetId && database) {
      // Log the post to database
      await database.logAutonomousAction('post', context || 'Manual post', { platform: 'twitter' }, true);
    }

    if (tweetId) {
      res.json({ success: true, tweetId, message: "Tweet posted by MNEX" });
    } else {
      res.status(500).json({ error: "Failed to post tweet" });
    }
  } catch (err) {
    console.error("[Twitter API] Error:", err);
    res.status(500).json({ error: "Twitter posting failed" });
  }
});

// Health check endpoint
app.get("/api/health", (req, res) => {
  res.json({ 
    status: "healthy", 
    timestamp: new Date().toISOString(),
    database: database ? "connected" : "disconnected",
    social: mnexSocial ? "active" : "inactive",
    autonomous: autonomousAI ? "active" : "inactive"
  });
});

// Learning status endpoint
app.get("/api/learning/status", async (req, res) => {
  try {
    if (!database) {
      return res.status(503).json({ error: "Database not available" });
    }

    // Get recent lessons
    const recentLessons = await database.getRecentLessons(10);
    const latestEvolution = await database.getLatestEvolution();
    
    // Calculate basic stats
    const totalLessons = recentLessons.length;
    const topics = [...new Set(recentLessons.map(l => l.topic))];
    const averageEngagement = totalLessons > 0 
      ? recentLessons.reduce((sum, l) => sum + l.engagement_score, 0) / totalLessons 
      : 0;

    res.json({
      status: "active",
      learning: {
        totalLessons,
        recentLessons: recentLessons.slice(0, 5),
        topics,
        averageEngagement: Math.round(averageEngagement),
        latestEvolution,
        isLearning: true // Could be enhanced with real-time learning detection
      },
      timestamp: new Date().toISOString()
    });
  } catch (err) {
    console.error("[Learning API] Error:", err);
    res.status(500).json({ error: "Failed to get learning status" });
  }
});

// Database endpoints
app.get("/api/posts", async (req, res) => {
  try {
    if (!database) {
      return res.status(503).json({ error: "Database not available" });
    }
    
    const limit = parseInt(req.query.limit as string) || 10;
    const posts = await database.getRecentPosts(limit);
    res.json({ success: true, posts });
  } catch (err) {
    console.error("[Database API] Error:", err);
    res.status(500).json({ error: "Failed to fetch posts" });
  }
});

app.get("/api/comments", async (req, res) => {
  try {
    if (!database) {
      return res.status(503).json({ error: "Database not available" });
    }
    
    const comments = await database.getUnrepliedComments();
    res.json({ success: true, comments });
  } catch (err) {
    console.error("[Database API] Error:", err);
    res.status(500).json({ error: "Failed to fetch comments" });
  }
});

// Autonomous AI control
app.post("/api/autonomous/start", (req, res) => {
  try {
    if (!autonomousAI) {
      return res.status(503).json({ error: "Autonomous AI not available" });
    }
    
    autonomousAI.startAutonomousMode();
    res.json({ success: true, message: "Autonomous mode started" });
  } catch (err) {
    console.error("[Autonomous API] Error:", err);
    res.status(500).json({ error: "Failed to start autonomous mode" });
  }
});

// v2.5 Autonomous Scheduler control
app.get("/api/autonomous/status", (req, res) => {
  try {
    if (!autonomousScheduler) {
      return res.status(503).json({ error: "Autonomous Scheduler not available" });
    }
    
    const status = autonomousScheduler.getStatus();
    res.json({ success: true, status });
  } catch (err) {
    console.error("[Autonomous API] Error:", err);
    res.status(500).json({ error: "Failed to get autonomous status" });
  }
});

app.post("/api/autonomous/force-learning", async (req, res) => {
  try {
    if (!autonomousScheduler) {
      return res.status(503).json({ error: "Autonomous Scheduler not available" });
    }
    
    await autonomousScheduler.forceLearningCycle();
    res.json({ success: true, message: "Forced learning cycle initiated" });
  } catch (err) {
    console.error("[Autonomous API] Error:", err);
    res.status(500).json({ error: "Failed to force learning cycle" });
  }
});

app.post("/api/autonomous/force-report", async (req, res) => {
  try {
    if (!autonomousScheduler) {
      return res.status(503).json({ error: "Autonomous Scheduler not available" });
    }
    
    await autonomousScheduler.forceDailyReport();
    res.json({ success: true, message: "Forced daily report initiated" });
  } catch (err) {
    console.error("[Autonomous API] Error:", err);
    res.status(500).json({ error: "Failed to force daily report" });
  }
});

// Whitepaper route
app.get("/whitepaper", (req, res) => {
  res.sendFile(path.join(__dirname, 'public/index.html'));
});

// Serve frontend for all other routes (SPA)
app.get('*', (req, res) => {
  res.sendFile(path.join(__dirname, 'public/index.html'));
});

const port = Number(process.env.PORT || 8787);
app.listen(port, async () => {
  console.log(`[MNEX] server online on :${port}`);
  console.log(`[MNEX] Environment: ${process.env.NODE_ENV || 'development'}`);
  if (process.env.NODE_ENV === 'production') {
    console.log(`[MNEX] Frontend served from /web/dist`);
  }

  // Initialize database after server starts
  try {
    database = new Database();
    await database.initialize();
    console.log(`[MNEX] Database initialized`);
  } catch (e) {
    console.warn("[MNEX] Database init failed:", e);
  }

  // Start Twitter autonomous posting if enabled
  if (TWITTER_ENABLED && process.env.TWITTER_AUTONOMOUS_POSTING === 'true') {
    const intervalHours = parseInt(process.env.TWITTER_POST_INTERVAL_HOURS || '6');
    console.log(`[Twitter] Autonomous posting enabled - every ${intervalHours} hours`);
    
    // Pass Telegram bot for cross-posting notifications
    startAutonomousPosting(intervalHours, telegramBot, CHANNEL_ID);
  } else if (!TWITTER_ENABLED) {
    console.log('[Twitter] Not configured - add API keys to .env to enable');
  } else {
    console.log('[Twitter] Autonomous posting disabled in config');
  }
  
  // Initialize Autonomous AI after database
  try {
    autonomousAI = new AutonomousAI(database);
    autonomousAI.startAutonomousMode();
    console.log("[MNEX] Legacy Autonomous AI initialized and started");
  } catch (e) {
    console.warn("[MNEX] Legacy Autonomous AI init failed:", e);
  }

  // Initialize new v2.5 Autonomous Scheduler
  try {
    autonomousScheduler = new AutonomousScheduler(database, telegramBot, CHANNEL_ID);
    autonomousScheduler.start();
    console.log("[MNEX] v2.5 Autonomous Scheduler initialized and started");
  } catch (e) {
    console.warn("[MNEX] v2.5 Autonomous Scheduler init failed:", e);
  }
});

